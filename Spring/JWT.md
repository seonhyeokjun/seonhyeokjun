
# JWT 학습 목적 및 설명

## 1. 학습 목적
회사에서 프로젝트를 시작하면서 로그인 서비스를 만들어야 했다. <br>
세션로그인 방식은 서버를 부하가 심해지기때문에 JWT 인증토큰 방식으로 서비스를 만들어야 했다. <br>
이 문서는 로그인서비스를 만들면서 배웠던 내용을 기록하기 위해서 적는다. <br>
JWT (JSON Web Token)를 학습하는 주요 목적은 **애플리케이션에서 인증 및 권한 부여**를 효율적으로 관리하는 방법을 이해하고, 이를 통해 **보안성을 강화**하는 것이다. <br> 
JWT는 **토큰 기반 인증 시스템**으로, 클라이언트와 서버 간의 인증 정보를 안전하게 주고받을 수 있는 방법을 제공한다.

학습의 주요 목표는 다음과 같다.
- **인증 및 권한 부여**: JWT를 사용하여 사용자 인증 정보를 안전하게 관리하고, 권한 부여 과정을 간소화하는 방법을 익힌다.
- **세션 관리의 대안**: 기존의 서버 세션 관리 대신 JWT를 사용하여 상태가 없는(stateless) 인증 방식을 이해하고 적용할 수 있다.
- **보안성 향상**: JWT의 구조와 서명 메커니즘을 학습하여, 인증 시스템의 보안을 강화할 수 있는 방법을 습득한다.

## 2. JWT란?
JWT는 JSON 형식의 정보를 **디지털 서명**을 통해 안전하게 주고받기 위한 **토큰 기반 인증 방식**이다. JWT는 주로 **인증**과 **권한 부여**에 사용되며, 한 번 생성된 토큰은 클라이언트 측에 저장되어, 서버가 지속적으로 사용자 상태를 관리하지 않고도 인증할 수 있게 한다.

### JWT의 주요 특징:
- **자체 포함 토큰**: JWT는 필요한 모든 정보를 자체적으로 포함하여 서버에서 별도의 세션을 유지할 필요가 없다.
- **경량화**: JSON 기반으로 토큰이 생성되므로, 비교적 경량이며 네트워크 성능에 부담을 주지 않는다.
- **확장성**: 다양한 애플리케이션 및 서비스에서 쉽게 확장하여 사용할 수 있다.

## 3. JWT의 구조
JWT는 **헤더**, **페이로드**, **서명**의 세 부분으로 구성된다. 각각의 구성 요소는 마침표(`.`)로 구분되며, **Base64URL**로 인코딩된다.

### 3.1. 헤더 (Header)
헤더에는 토큰의 타입(JWT)과 사용된 서명 알고리즘(예: HMAC, RSA)이 포함된다.

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

### 3.2. 페이로드 (Payload)
페이로드에는 **클레임(Claim)**이라 불리는 정보들이 포함된다. 클레임은 토큰에 담길 데이터로, 보통 사용자 정보나 토큰의 만료 시간을 정의한다.

- **등록된 클레임(Registered Claims)**: `iss`(발행자), `exp`(만료 시간), `sub`(주제)와 같은 표준 클레임.
- **공개 클레임(Public Claims)**: 자유롭게 정의하여 사용할 수 있는 클레임.
- **비공개 클레임(Private Claims)**: 클라이언트와 서버 간의 협의에 따라 정의된 클레임.

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```

### 3.3. 서명 (Signature)
서명은 헤더와 페이로드를 합친 후 **비밀키**로 서명한 값이다. 이를 통해 토큰의 무결성을 검증할 수 있으며, 서명이 유효한지 확인함으로써 데이터가 위변조되지 않았음을 보장한다.

```bash
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)
```

## 4. JWT의 동작 방식
JWT는 기본적으로 서버에서 생성하여 클라이언트에 전달되고, 클라이언트는 이후 요청 시 토큰을 포함하여 서버에 전달한다. 서버는 토큰을 검증하고, 요청한 자원이 적합한 사용자인지 확인한다.

### 동작 과정:
1. **사용자 로그인**: 사용자가 로그인하면 서버는 사용자 정보를 확인한 후, 해당 정보를 담은 JWT를 생성한다.
2. **JWT 전달**: 생성된 JWT는 클라이언트(보통 브라우저 또는 모바일 앱)로 전달된다.
3. **요청 시 JWT 포함**: 클라이언트는 이후 API 요청 시 HTTP 헤더에 JWT를 포함시켜 서버에 보낸다.
4. **서버에서 JWT 검증**: 서버는 수신한 JWT의 서명을 확인하여, 유효한 토큰인지 검증한다.
5. **자원 접근 허용**: 검증이 완료되면 서버는 요청한 자원을 제공하거나, 권한이 부족하면 접근을 거부한다.

## 5. JWT의 장점과 단점
### 5.1. 장점:
- **상태 유지 불필요**: JWT는 상태가 없는(stateless) 방식이므로, 서버에서 세션을 유지할 필요가 없다.
- **확장성**: 여러 서버나 서비스 간에 인증을 공유하기 쉽다.
- **보안성**: 서명을 통해 토큰이 위변조되지 않았음을 검증할 수 있다.

### 5.2. 단점:
- **페이로드 크기**: 페이로드에 포함된 정보가 많을 경우, 토큰 크기가 커질 수 있다.
- **토큰 만료 처리**: 한 번 발급된 JWT는 만료 시간이 지날 때까지 유효하므로, 만료 전에 이를 무효화하기가 어렵다.
- **비밀키 관리**: 서명에 사용되는 비밀키가 유출되면 토큰이 위변조될 수 있는 위험이 있다.

## 6. JWT 사용 사례
JWT는 다양한 시나리오에서 사용되며, 주로 다음과 같은 경우에 유용합니다:
- **API 인증**: RESTful API에서 클라이언트의 인증을 위해 사용된다.
- **싱글 사인 온(SSO)**: 여러 서비스 간에 하나의 로그인으로 인증을 공유하는 시스템에서 JWT를 사용한다.
- **분산 시스템**: 여러 마이크로서비스 간의 인증과 권한 관리를 효율적으로 처리하기 위해 JWT를 활용할 수 있다.

## 7. 결론
JWT는 **경량화된 인증 방식**으로, 세션 관리가 필요 없는 RESTful API나 분산 시스템에서 특히 유용합니다. JWT를 사용하면 상태가 없는 인증을 통해 애플리케이션의 확장성을 높일 수 있으며, 클라이언트와 서버 간의 인증 정보를 안전하게 주고받을 수 있는 방법을 제공한다.

## 8. 적용
JWT에 대한 기본 개념에 대해서 알게 되었고 이제 Spring에 직접 구현해보는 문서를 쓸 예정이다.
